#!/usr/bin/env python3
# Script to convert IMOD model to ChimeraX cmm file for quick visualization
# Huy Bui, McGill University

#!/usr/bin/env python3
# Script to convert IMOD model to ChimeraX cmm file for quick visualization
# Huy Bui, McGill University

import argparse
import subprocess
import xml.etree.ElementTree as ET
from typing import List

# Function to run IMOD commands
def run_imod_command(command: List[str], input_file: str, output_file: str) -> bool:
    """
    Runs an IMOD command with the given input and output files.
    
    Args:
        command: List of command arguments
        input_file: Path to the input file
        output_file: Path to the output file
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error processing {input_file}: {e.stderr.decode()}")  
        return False

# Function to convert .mod to .txt using model2point
def run_model2point(input_mod: str, output_txt: str) -> bool:
    """
    Runs the IMOD model2point command with the given input and output files.
    
    Args:
        input_mod: Path to the input .mod file
        output_txt: Path to the output .txt file
        
    Returns:
        bool: True if successful, False otherwise
    """
    command = ["model2point", "-Object", "-Contour", input_mod, output_txt]
    return run_imod_command(command, input_mod, output_txt)

# Function to parse the .txt file
def parse_input_file(filename: str, scale_factor: float) -> List[dict]:
    """
    Parses the input .txt file generated by model2point.
    
    Args:
        filename: Path to the input .txt file
        scale_factor: Factor to scale the coordinates by
        
    Returns:
        List[dict]: List of markers, each represented as a dictionary
    """
    markers = []
    with open(filename, "r") as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) == 5:
                group_id = int(parts[1])  # Second column (group ID)
                x, y, z = map(float, parts[2:5])  # x, y, z coordinates
                # Scale the coordinates
                x *= scale_factor
                y *= scale_factor
                z *= scale_factor
                markers.append({"group_id": group_id, "x": x, "y": y, "z": z})
    return markers

def generate_cmm_file(markers: List[dict], output_filename: str, radius: float, color: List[float], name: str, scatter: bool) -> None:
    """
    Generates a .cmm file from the parsed markers with newlines and indentation for readability.
    
    Args:
        markers: List of markers
        output_filename: Path to the output .cmm file
        radius: Radius of the markers and links
        color: Color for the markers and links in the format [r, g, b]
        name: Name for the marker set
        scatter: If True, do not print any links
    """
    # Create the root element
    marker_set = ET.Element("marker_set", name=name)

    # Add markers to the XML
    for i, marker in enumerate(markers, start=1):
        marker_attribs = {
            "id": str(i),
            "x": str(marker["x"]),
            "y": str(marker["y"]),
            "z": str(marker["z"]),
            "radius": str(radius),
        }
        # Add color if provided
        if color:
            marker_attribs.update({"r": str(color[0]), "g": str(color[1]), "b": str(color[2])})
        ET.SubElement(marker_set, "marker", **marker_attribs)

    # Add links between consecutive markers in the same group (if scatter is False)
    if not scatter:
        for i in range(1, len(markers)):
            if markers[i]["group_id"] == markers[i - 1]["group_id"]:
                link_attribs = {
                    "id1": str(i),
                    "id2": str(i + 1),
                    "radius": str(radius),
                }
                # Add color if provided
                if color:
                    link_attribs.update({"r": str(color[0]), "g": str(color[1]), "b": str(color[2])})
                ET.SubElement(marker_set, "link", **link_attribs)

    # Create an ElementTree object
    tree = ET.ElementTree(marker_set)

    # Function to add indentation and newlines to the XML
    def indent(elem, level=0):
        """Recursively adds indentation and newlines to the XML tree."""
        indent_str = "\n" + level * "  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = indent_str + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = indent_str
            for child in elem:
                indent(child, level + 1)
            if not child.tail or not child.tail.strip():
                child.tail = indent_str
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = indent_str

    # Indent the XML tree
    indent(marker_set)

    # Write to the output file
    tree.write(output_filename, encoding="UTF-8", xml_declaration=True)

    print(f"CMM file '{output_filename}' created successfully!")

# Main program
if __name__ == "__main__":
    # Set up argument parser
    parser = argparse.ArgumentParser(description="Convert an IMOD .mod file to a .cmm file.")
    parser.add_argument("--r", type=float, default=8, required=True, help="Radius of the markers and links")
    parser.add_argument("--color", type=str, help="Color for markers and links in the format 'r,g,b' (e.g., '1,0.5,1')")
    parser.add_argument("--name", type=str, default="marker_set1", help="Name for the marker set (e.g., 'doublet')")
    parser.add_argument("--i", type=str, required=True, help="Input .mod file")
    parser.add_argument("--scatter", action="store_true", default=False,
                        help="If set, do not print any links in the output cmm file.")
    parser.add_argument("--scale_factor", type=float, default=1.0,
                        help="Multiply X to coordinate x, y, z in the cmm file. Default is 1.")
    args = parser.parse_args()
    
    
    # Generate output filename by replacing ".mod" with ".cmm"
    if args.i.endswith(".mod"):
        output_cmm = args.i.replace(".mod", ".cmm")
    else:
        print("Input file must have a .mod extension.")
        exit(1)
        
    if args.name == "marker_set1":
        marker_name = args.i.replace(".mod", "")


    # Parse the color argument
    color = None
    if args.color:
        try:
            color = list(map(float, args.color.split(",")))
            if len(color) != 3:
                raise ValueError("Color must have exactly 3 values (r, g, b).")
        except ValueError as e:
            print(f"Error parsing color: {e}")
            exit(1)

    # Convert .mod to .txt using model2point
    # To replace with imodmodel in the future
    intermediate_txt = args.i.replace(".mod", ".txt")
    if not run_model2point(args.i, intermediate_txt):
        print(f"Failed to convert {args.i} to {intermediate_txt}.")
        exit(1)

    # Parse the intermediate .txt file with scaling
    markers = parse_input_file(intermediate_txt, args.scale_factor)

    # Generate the .cmm file
    generate_cmm_file(markers, output_cmm, args.r, color, marker_name, args.scatter)